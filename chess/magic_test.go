package chess

import (
	"fmt"
	"testing"
)

func TestRookMask(t *testing.T) {
	tests := []struct {
		square   string
		expected Bitboard
	}{
		// these hexidecimals can be generated by printing a bitboard
		// to the console, visually verifying it is correct, and then
		// printing the bitboard as a hexidecimal,
		// e.g. fmt.Printf("%#x", mask)
		{"a1", 0x0101010101017e},
		{"h8", 0x7e80808080808000},
		{"a8", 0x7e01010101010100},
		{"h1", 0x8080808080807e},
		{"a4", 0x101017e010100},
		{"h5", 0x80807e80808000},
		{"d4", 0x8080876080800},
		{"e5", 0x10106e10101000},
		{"g7", 0x3e404040404000},
	}

	for _, tt := range tests {
		t.Run(fmt.Sprintf("square %s", tt.square), func(t *testing.T) {
			mask := RookRelevantMask(RankFileToBitIndex(tt.square[0], tt.square[1]))
			if mask != tt.expected {
				t.Errorf("expected: \n%sgot: \n%s", ToString(tt.expected), ToString(mask))
				t.Errorf("expected hex: %#x, actual: %#x", tt.expected, mask)
			}
		})
	}
}

func TestGenerateOccupancyVariations(t *testing.T) {
	// Simple mask: bits 0, 1, and 3 set (0b1011)
	mask := Bitboard(0b1011)

	expected := []Bitboard{
		0b0000,
		0b0001,
		0b0010,
		0b0011,
		0b1000,
		0b1001,
		0b1010,
		0b1011,
	}

	got := GenerateOccupancyVariations(mask)

	if len(got) != len(expected) {
		t.Fatalf("Expected %d variations, got %d", len(expected), len(got))
	}

	// Check that each expected variation exists in the result
	for _, exp := range expected {
		found := false
		for _, g := range got {
			if g == exp {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("Expected variation %b not found in result", exp)
		}
	}
}

func TestComputeRookAttacks(t *testing.T) {
	// Example: rook on d4 (square 27)
	rookSquare := 27

	// Occupancy: blockers at d6 (square 43) and b4 (square 25)
	var occupancy Bitboard = (1 << 43) | (1 << 25)

	// Expected attacks manually calculated:
	expected := Bitboard(0)
	// north until d6
	expected |= (1 << 35) | (1 << 43)
	// south until edge
	expected |= (1 << 19) | (1 << 11) | (1 << 3)
	// west until b4 (blocked)
	expected |= (1 << 26) | (1 << 25)
	// east until edge
	expected |= (1 << 28) | (1 << 29) | (1 << 30) | (1 << 31)

	got := ComputeRookAttacks(rookSquare, occupancy)

	if got != expected {
		t.Errorf("ComputeRookAttacks failed.\nGot:      %064b\nExpected: %064b", got, expected)
	}
}

func TestRookRelevantBits(t *testing.T) {
	cases := map[string]uint{
		"a1": 12,
		"d1": 11,
		"d4": 10,
		"h8": 12,
	}
	for square, expected := range cases {
		squareIdx := RankFileToBitIndex(square[0], square[1])
		got := RookRelevantBits(squareIdx)
		if got != expected {
			t.Errorf("%s: expected %d, got %d", square, expected, got)
		}
	}
}

func TestMagicIndex(t *testing.T) {
	pos := Position{}
	square := "a1"
	pos.SetPiece('R', square)

	sqIdx := RankFileToBitIndex(square[0], square[1])
	mask := RookMasks[sqIdx]
	magic := RookMagics[sqIdx]
	relevantBits := RookRelevantBitsMap[sqIdx]

	occupancy := pos.GetOccupiedSquares()
	magicIndex := MagicIndex(sqIdx, occupancy, mask, magic, relevantBits)
	actual := RookAttackTables[sqIdx][magicIndex]

	expected := Bitboard(0x01010101010101FE)
	if actual != expected {
		t.Errorf("a1 empty: got\n%s, expected\n%s", ToString(actual), ToString(expected))
		t.Errorf("expected hex: %#x, actual: %#x", expected, actual)
	}

	// Case 2: add blocker on a3
	pos.SetPiece('P', "a3")
	occupancy = pos.GetOccupiedSquares()
	magicIndex = MagicIndex(sqIdx, occupancy, mask, magic, relevantBits)
	actual = RookAttackTables[sqIdx][magicIndex]

	// Expected: rook sees a2 and a3, plus rank 1 to the right
	expected = Bitboard(0x101fe)
	if actual != expected {
		t.Errorf("a1 with blocker a3: got\n%s, expected\n%s", ToString(actual), ToString(expected))
		t.Errorf("expected hex: %#x, actual: %#x", expected, actual)
	}

	// Case 3: add another blocker on c1
	pos.SetPiece('P', "c1")
	occupancy = pos.GetOccupiedSquares()
	magicIndex = MagicIndex(sqIdx, occupancy, mask, magic, relevantBits)
	actual = RookAttackTables[sqIdx][magicIndex]

	// Expected: rook can go right to b1 (blocked at c1), up to a3
	expected = Bitboard(0x10106)
	if actual != expected {
		t.Errorf("a1 with blockers a3+c1: got\n%s, expected\n%s", ToString(actual), ToString(expected))
		t.Errorf("expected hex: %#x, actual: %#x", expected, actual)
	}
}
