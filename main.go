package main

import (
	"flag"
	"fmt"
	"os"
	"strings"

	log "github.com/sirupsen/logrus"

	"github.com/liam-hatcher/gohobbyengine/chess"
	"github.com/liam-hatcher/gohobbyengine/uci"
)

func generateRookMagicFile() {
	log.Info("Generating rook magic values")

	total := 64
	progressCount := 0
	progress := func() {
		progressCount++
		percent := float64(progressCount) / float64(total) * 100
		blocks := int(percent / 2) // 50 chars wide
		fmt.Printf("\r[%s%s] %.1f%%", strings.Repeat("â–ˆ", blocks), strings.Repeat(" ", 50-blocks), percent)
	}

	magics, rookAttackTables := chess.GenerateRookMagic(progress)
	fmt.Println()

	log.Info("Rook magic generation done!")

	f, err := os.Create("chess/rook_magics.go")
	if err != nil {
		log.WithError(err).Error("Error creating file")
		return
	}
	defer f.Close()

	log.Info("Writing rook magic numbers to rook_magics.go")

	// Write file header
	fmt.Fprintln(f, "// Code generated by magic generator; DO NOT EDIT.")
	fmt.Fprintln(f, "// This file contains precomputed rook magics and attack tables.")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "package chess")
	fmt.Fprintln(f)

	// Write rook magics
	fmt.Fprintln(f, "var RookMagics = [64]uint64{")
	for _, m := range magics {
		fmt.Fprintf(f, "    0x%016X,\n", m)
	}
	fmt.Fprintln(f, "}")
	log.Info("Rook magic numbers written to rook_magics.go")

	// Write rook attack tables
	log.Info("Writing rook attack tables to rook_magics.go")
	fmt.Fprintln(f, "// Precomputed rook attack tables")
	fmt.Fprintln(f, "var RookAttackTables = [64][]Bitboard{")
	for sq, table := range rookAttackTables {
		fmt.Fprintf(f, "    /* %s */ {\n", chess.BitIndexToRankFile(sq))
		for _, attacks := range table {
			fmt.Fprintf(f, "        0x%016X,\n", attacks)
		}
		fmt.Fprintln(f, "    },")
	}
	fmt.Fprintln(f, "}")
	log.Info("Rook attack tables written to rook_magics.go")

	log.Info("Generating relevantBits mapping")
	// Compute relevant bits for each square from the mask
	relevantBits := make([]int, 64)
	for sq := 0; sq < 64; sq++ {
		mask := chess.RookRelevantMask(sq)
		relevantBits[sq] = chess.PopCount(mask) // popCount = number of 1s in mask
	}

	// Write rook relevant bits
	fmt.Fprintln(f, "var RookRelevantBitsMap = [64]int{")
	for _, rb := range relevantBits {
		fmt.Fprintf(f, "    %d,\n", rb)
	}
	fmt.Fprintln(f, "}")
	log.Info("Rook relevant bits written to rook_magics.go")

	log.Info("Success!")

	log.Info("Generating rook masks for all 64 squares")

	rookMasks := [64]chess.Bitboard{}
	for sq := 0; sq < 64; sq++ {
		mask := chess.RookRelevantMask(sq)
		rookMasks[sq] = mask
		log.Debugf("Rook mask for %s = 0x%016X", chess.BitIndexToRankFile(sq), mask)
	}

	// Write to file
	fmt.Fprintln(f, "var RookMasks = [64]Bitboard{")
	for _, mask := range rookMasks {
		fmt.Fprintf(f, "    0x%016X,\n", mask)
	}
	fmt.Fprintln(f, "}")
	log.Info("Rook masks written to rook_magics.go")
}

func parseFlags() bool {
	genRook := flag.Bool("gen-rook-magics", false, "Generate rook magic numbers and attack tables")
	flag.Parse()

	if *genRook {
		generateRookMagicFile()
		return true
	}

	return false
}

func main() {

	hasFlag := parseFlags()

	if hasFlag {
		return
	}

	position := chess.NewPosition()
	engine := uci.NewEngine()
	engine.Run(position)
}
